type Actor implements Node {
  actorId: Int!

  """
  Reads and enables pagination through a set of `FilmActor`.
  """
  filmActors(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsConnection!
  firstName: String!
  lastName: String!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Actor` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ActorCondition {
  """
  Checks for equality with the object’s `actorId` field.
  """
  actorId: Int

  """
  Checks for equality with the object’s `firstName` field.
  """
  firstName: String

  """
  Checks for equality with the object’s `lastName` field.
  """
  lastName: String

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime
}

type ActorInfo {
  actorId: Int
  filmInfo: String
  firstName: String
  lastName: String
}

"""
A condition to be used against `ActorInfo` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ActorInfoCondition {
  """
  Checks for equality with the object’s `actorId` field.
  """
  actorId: Int

  """
  Checks for equality with the object’s `filmInfo` field.
  """
  filmInfo: String

  """
  Checks for equality with the object’s `firstName` field.
  """
  firstName: String

  """
  Checks for equality with the object’s `lastName` field.
  """
  lastName: String
}

"""
A connection to a list of `ActorInfo` values.
"""
type ActorInfosConnection {
  """
  A list of edges which contains the `ActorInfo` and cursor to aid in pagination.
  """
  edges: [ActorInfosEdge!]!

  """
  A list of `ActorInfo` objects.
  """
  nodes: [ActorInfo!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `ActorInfo` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `ActorInfo` edge in the connection.
"""
type ActorInfosEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `ActorInfo` at the end of the edge.
  """
  node: ActorInfo!
}

"""
Methods to use when ordering `ActorInfo`.
"""
enum ActorInfosOrderBy {
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FILM_INFO_ASC
  FILM_INFO_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  NATURAL
}

"""
An input for mutations affecting `Actor`
"""
input ActorInput {
  actorId: Int
  firstName: String!
  lastName: String!
  lastUpdate: Datetime
}

"""
Represents an update to a `Actor`. Fields that are set will be updated.
"""
input ActorPatch {
  actorId: Int
  firstName: String
  lastName: String
  lastUpdate: Datetime
}

"""
A connection to a list of `Actor` values.
"""
type ActorsConnection {
  """
  A list of edges which contains the `Actor` and cursor to aid in pagination.
  """
  edges: [ActorsEdge!]!

  """
  A list of `Actor` objects.
  """
  nodes: [Actor!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Actor` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Actor` edge in the connection.
"""
type ActorsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Actor` at the end of the edge.
  """
  node: Actor!
}

"""
Methods to use when ordering `Actor`.
"""
enum ActorsOrderBy {
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Address implements Node {
  address: String!
  address2: String
  addressId: Int!

  """
  Reads a single `City` that is related to this `Address`.
  """
  city: City
  cityId: Int!

  """
  Reads and enables pagination through a set of `Customer`.
  """
  customers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Customer`.
    """
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersConnection!
  district: String!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  phone: String!
  postalCode: String

  """
  Reads and enables pagination through a set of `Staff`.
  """
  staffs(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Staff`.
    """
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffConnection!

  """
  Reads and enables pagination through a set of `Store`.
  """
  stores(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresConnection!
}

"""
A condition to be used against `Address` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AddressCondition {
  """
  Checks for equality with the object’s `address` field.
  """
  address: String

  """
  Checks for equality with the object’s `address2` field.
  """
  address2: String

  """
  Checks for equality with the object’s `addressId` field.
  """
  addressId: Int

  """
  Checks for equality with the object’s `cityId` field.
  """
  cityId: Int

  """
  Checks for equality with the object’s `district` field.
  """
  district: String

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `phone` field.
  """
  phone: String

  """
  Checks for equality with the object’s `postalCode` field.
  """
  postalCode: String
}

"""
An input for mutations affecting `Address`
"""
input AddressInput {
  address: String!
  address2: String
  addressId: Int
  cityId: Int!
  district: String!
  lastUpdate: Datetime
  phone: String!
  postalCode: String
}

"""
Represents an update to a `Address`. Fields that are set will be updated.
"""
input AddressPatch {
  address: String
  address2: String
  addressId: Int
  cityId: Int
  district: String
  lastUpdate: Datetime
  phone: String
  postalCode: String
}

"""
A connection to a list of `Address` values.
"""
type AddressesConnection {
  """
  A list of edges which contains the `Address` and cursor to aid in pagination.
  """
  edges: [AddressesEdge!]!

  """
  A list of `Address` objects.
  """
  nodes: [Address!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Address` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Address` edge in the connection.
"""
type AddressesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Address` at the end of the edge.
  """
  node: Address!
}

"""
Methods to use when ordering `Address`.
"""
enum AddressesOrderBy {
  ADDRESS2_ASC
  ADDRESS2_DESC
  ADDRESS_ASC
  ADDRESS_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  DISTRICT_ASC
  DISTRICT_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PHONE_ASC
  PHONE_DESC
  POSTAL_CODE_ASC
  POSTAL_CODE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A floating point number that requires more precision than IEEE 754 binary 64
"""
scalar BigFloat

"""
A connection to a list of `Category` values.
"""
type CategoriesConnection {
  """
  A list of edges which contains the `Category` and cursor to aid in pagination.
  """
  edges: [CategoriesEdge!]!

  """
  A list of `Category` objects.
  """
  nodes: [Category!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Category` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Category` edge in the connection.
"""
type CategoriesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Category` at the end of the edge.
  """
  node: Category!
}

"""
Methods to use when ordering `Category`.
"""
enum CategoriesOrderBy {
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Category implements Node {
  categoryId: Int!

  """
  Reads and enables pagination through a set of `FilmCategory`.
  """
  filmCategories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesConnection!
  lastUpdate: Datetime!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Category` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CategoryCondition {
  """
  Checks for equality with the object’s `categoryId` field.
  """
  categoryId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
An input for mutations affecting `Category`
"""
input CategoryInput {
  categoryId: Int
  lastUpdate: Datetime
  name: String!
}

"""
Represents an update to a `Category`. Fields that are set will be updated.
"""
input CategoryPatch {
  categoryId: Int
  lastUpdate: Datetime
  name: String
}

"""
A connection to a list of `City` values.
"""
type CitiesConnection {
  """
  A list of edges which contains the `City` and cursor to aid in pagination.
  """
  edges: [CitiesEdge!]!

  """
  A list of `City` objects.
  """
  nodes: [City!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `City` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `City` edge in the connection.
"""
type CitiesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `City` at the end of the edge.
  """
  node: City!
}

"""
Methods to use when ordering `City`.
"""
enum CitiesOrderBy {
  CITY_ASC
  CITY_DESC
  CITY_ID_ASC
  CITY_ID_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type City implements Node {
  """
  Reads and enables pagination through a set of `Address`.
  """
  addresses(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection!
  city: String!
  cityId: Int!

  """
  Reads a single `Country` that is related to this `City`.
  """
  country: Country
  countryId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `City` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CityCondition {
  """
  Checks for equality with the object’s `city` field.
  """
  city: String

  """
  Checks for equality with the object’s `cityId` field.
  """
  cityId: Int

  """
  Checks for equality with the object’s `countryId` field.
  """
  countryId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime
}

"""
An input for mutations affecting `City`
"""
input CityInput {
  city: String!
  cityId: Int
  countryId: Int!
  lastUpdate: Datetime
}

"""
Represents an update to a `City`. Fields that are set will be updated.
"""
input CityPatch {
  city: String
  cityId: Int
  countryId: Int
  lastUpdate: Datetime
}

"""
A connection to a list of `Country` values.
"""
type CountriesConnection {
  """
  A list of edges which contains the `Country` and cursor to aid in pagination.
  """
  edges: [CountriesEdge!]!

  """
  A list of `Country` objects.
  """
  nodes: [Country!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Country` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Country` edge in the connection.
"""
type CountriesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Country` at the end of the edge.
  """
  node: Country!
}

"""
Methods to use when ordering `Country`.
"""
enum CountriesOrderBy {
  COUNTRY_ASC
  COUNTRY_DESC
  COUNTRY_ID_ASC
  COUNTRY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type Country implements Node {
  """
  Reads and enables pagination through a set of `City`.
  """
  cities(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `City`.
    """
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesConnection!
  country: String!
  countryId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Country` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CountryCondition {
  """
  Checks for equality with the object’s `country` field.
  """
  country: String

  """
  Checks for equality with the object’s `countryId` field.
  """
  countryId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime
}

"""
An input for mutations affecting `Country`
"""
input CountryInput {
  country: String!
  countryId: Int
  lastUpdate: Datetime
}

"""
Represents an update to a `Country`. Fields that are set will be updated.
"""
input CountryPatch {
  country: String
  countryId: Int
  lastUpdate: Datetime
}

"""
All input for the create `Actor` mutation.
"""
input CreateActorInput {
  """
  The `Actor` to be created by this mutation.
  """
  actor: ActorInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `Actor` mutation.
"""
type CreateActorPayload {
  """
  The `Actor` that was created by this mutation.
  """
  actor: Actor

  """
  An edge for our `Actor`. May be used by Relay 1.
  """
  actorEdge(
    """
    The method to use when ordering `Actor`.
    """
    orderBy: [ActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActorsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Address` mutation.
"""
input CreateAddressInput {
  """
  The `Address` to be created by this mutation.
  """
  address: AddressInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `Address` mutation.
"""
type CreateAddressPayload {
  """
  The `Address` that was created by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  Reads a single `City` that is related to this `Address`.
  """
  city: City

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Category` mutation.
"""
input CreateCategoryInput {
  """
  The `Category` to be created by this mutation.
  """
  category: CategoryInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `Category` mutation.
"""
type CreateCategoryPayload {
  """
  The `Category` that was created by this mutation.
  """
  category: Category

  """
  An edge for our `Category`. May be used by Relay 1.
  """
  categoryEdge(
    """
    The method to use when ordering `Category`.
    """
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `City` mutation.
"""
input CreateCityInput {
  """
  The `City` to be created by this mutation.
  """
  city: CityInput!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our create `City` mutation.
"""
type CreateCityPayload {
  """
  The `City` that was created by this mutation.
  """
  city: City

  """
  An edge for our `City`. May be used by Relay 1.
  """
  cityEdge(
    """
    The method to use when ordering `City`.
    """
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Country` that is related to this `City`.
  """
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Country` mutation.
"""
input CreateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Country` to be created by this mutation.
  """
  country: CountryInput!
}

"""
The output of our create `Country` mutation.
"""
type CreateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Country` that was created by this mutation.
  """
  country: Country

  """
  An edge for our `Country`. May be used by Relay 1.
  """
  countryEdge(
    """
    The method to use when ordering `Country`.
    """
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Customer` mutation.
"""
input CreateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Customer` to be created by this mutation.
  """
  customer: CustomerInput!
}

"""
The output of our create `Customer` mutation.
"""
type CreateCustomerPayload {
  """
  Reads a single `Address` that is related to this `Customer`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Customer` that was created by this mutation.
  """
  customer: Customer

  """
  An edge for our `Customer`. May be used by Relay 1.
  """
  customerEdge(
    """
    The method to use when ordering `Customer`.
    """
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `FilmActor` mutation.
"""
input CreateFilmActorInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `FilmActor` to be created by this mutation.
  """
  filmActor: FilmActorInput!
}

"""
The output of our create `FilmActor` mutation.
"""
type CreateFilmActorPayload {
  """
  Reads a single `Actor` that is related to this `FilmActor`.
  """
  actor: Actor

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `FilmActor`.
  """
  film: Film

  """
  The `FilmActor` that was created by this mutation.
  """
  filmActor: FilmActor

  """
  An edge for our `FilmActor`. May be used by Relay 1.
  """
  filmActorEdge(
    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `FilmCategory` mutation.
"""
input CreateFilmCategoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `FilmCategory` to be created by this mutation.
  """
  filmCategory: FilmCategoryInput!
}

"""
The output of our create `FilmCategory` mutation.
"""
type CreateFilmCategoryPayload {
  """
  Reads a single `Category` that is related to this `FilmCategory`.
  """
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `FilmCategory`.
  """
  film: Film

  """
  The `FilmCategory` that was created by this mutation.
  """
  filmCategory: FilmCategory

  """
  An edge for our `FilmCategory`. May be used by Relay 1.
  """
  filmCategoryEdge(
    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Film` mutation.
"""
input CreateFilmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Film` to be created by this mutation.
  """
  film: FilmInput!
}

"""
The output of our create `Film` mutation.
"""
type CreateFilmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Film` that was created by this mutation.
  """
  film: Film

  """
  An edge for our `Film`. May be used by Relay 1.
  """
  filmEdge(
    """
    The method to use when ordering `Film`.
    """
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmsEdge

  """
  Reads a single `Language` that is related to this `Film`.
  """
  language: Language

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Inventory` mutation.
"""
input CreateInventoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Inventory` to be created by this mutation.
  """
  inventory: InventoryInput!
}

"""
The output of our create `Inventory` mutation.
"""
type CreateInventoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `Inventory`.
  """
  film: Film

  """
  The `Inventory` that was created by this mutation.
  """
  inventory: Inventory

  """
  An edge for our `Inventory`. May be used by Relay 1.
  """
  inventoryEdge(
    """
    The method to use when ordering `Inventory`.
    """
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InventoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Language` mutation.
"""
input CreateLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Language` to be created by this mutation.
  """
  language: LanguageInput!
}

"""
The output of our create `Language` mutation.
"""
type CreateLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Language` that was created by this mutation.
  """
  language: Language

  """
  An edge for our `Language`. May be used by Relay 1.
  """
  languageEdge(
    """
    The method to use when ordering `Language`.
    """
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the create `Payment` mutation.
"""
input CreatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Payment` to be created by this mutation.
  """
  payment: PaymentInput!
}

"""
The output of our create `Payment` mutation.
"""
type CreatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Payment`.
  """
  customer: Customer

  """
  The `Payment` that was created by this mutation.
  """
  payment: Payment

  """
  An edge for our `Payment`. May be used by Relay 1.
  """
  paymentEdge(
    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Rental` that is related to this `Payment`.
  """
  rental: Rental

  """
  Reads a single `Staff` that is related to this `Payment`.
  """
  staff: Staff
}

"""
All input for the create `Rental` mutation.
"""
input CreateRentalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Rental` to be created by this mutation.
  """
  rental: RentalInput!
}

"""
The output of our create `Rental` mutation.
"""
type CreateRentalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Rental`.
  """
  customer: Customer

  """
  Reads a single `Inventory` that is related to this `Rental`.
  """
  inventory: Inventory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Rental` that was created by this mutation.
  """
  rental: Rental

  """
  An edge for our `Rental`. May be used by Relay 1.
  """
  rentalEdge(
    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsEdge

  """
  Reads a single `Staff` that is related to this `Rental`.
  """
  staff: Staff
}

"""
All input for the create `Staff` mutation.
"""
input CreateStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Staff` to be created by this mutation.
  """
  staff: StaffInput!
}

"""
The output of our create `Staff` mutation.
"""
type CreateStaffPayload {
  """
  Reads a single `Address` that is related to this `Staff`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Staff` that was created by this mutation.
  """
  staff: Staff

  """
  An edge for our `Staff`. May be used by Relay 1.
  """
  staffEdge(
    """
    The method to use when ordering `Staff`.
    """
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffEdge
}

"""
All input for the create `Store` mutation.
"""
input CreateStoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The `Store` to be created by this mutation.
  """
  store: StoreInput!
}

"""
The output of our create `Store` mutation.
"""
type CreateStorePayload {
  """
  Reads a single `Address` that is related to this `Store`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Staff` that is related to this `Store`.
  """
  managerStaff: Staff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Store` that was created by this mutation.
  """
  store: Store

  """
  An edge for our `Store`. May be used by Relay 1.
  """
  storeEdge(
    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresEdge
}

"""
A location in a connection that can be used for resuming pagination.
"""
scalar Cursor

type Customer implements Node {
  active: Int
  activebool: Boolean!

  """
  Reads a single `Address` that is related to this `Customer`.
  """
  address: Address
  addressId: Int!
  createDate: Date!
  customerId: Int!
  email: String
  firstName: String!
  lastName: String!
  lastUpdate: Datetime

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Payment`.
  """
  payments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsConnection!

  """
  Reads and enables pagination through a set of `Rental`.
  """
  rentals(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsConnection!
  storeId: Int!
}

"""
A condition to be used against `Customer` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input CustomerCondition {
  """
  Checks for equality with the object’s `active` field.
  """
  active: Int

  """
  Checks for equality with the object’s `activebool` field.
  """
  activebool: Boolean

  """
  Checks for equality with the object’s `addressId` field.
  """
  addressId: Int

  """
  Checks for equality with the object’s `createDate` field.
  """
  createDate: Date

  """
  Checks for equality with the object’s `customerId` field.
  """
  customerId: Int

  """
  Checks for equality with the object’s `email` field.
  """
  email: String

  """
  Checks for equality with the object’s `firstName` field.
  """
  firstName: String

  """
  Checks for equality with the object’s `lastName` field.
  """
  lastName: String

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `storeId` field.
  """
  storeId: Int
}

"""
An input for mutations affecting `Customer`
"""
input CustomerInput {
  active: Int
  activebool: Boolean
  addressId: Int!
  createDate: Date
  customerId: Int
  email: String
  firstName: String!
  lastName: String!
  lastUpdate: Datetime
  storeId: Int!
}

type CustomerList {
  address: String
  city: String
  country: String
  id: Int
  name: String
  notes: String
  phone: String
  sid: Int
  zipCode: String
}

"""
A condition to be used against `CustomerList` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CustomerListCondition {
  """
  Checks for equality with the object’s `address` field.
  """
  address: String

  """
  Checks for equality with the object’s `city` field.
  """
  city: String

  """
  Checks for equality with the object’s `country` field.
  """
  country: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `name` field.
  """
  name: String

  """
  Checks for equality with the object’s `notes` field.
  """
  notes: String

  """
  Checks for equality with the object’s `phone` field.
  """
  phone: String

  """
  Checks for equality with the object’s `sid` field.
  """
  sid: Int

  """
  Checks for equality with the object’s `zipCode` field.
  """
  zipCode: String
}

"""
A connection to a list of `CustomerList` values.
"""
type CustomerListsConnection {
  """
  A list of edges which contains the `CustomerList` and cursor to aid in pagination.
  """
  edges: [CustomerListsEdge!]!

  """
  A list of `CustomerList` objects.
  """
  nodes: [CustomerList!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `CustomerList` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `CustomerList` edge in the connection.
"""
type CustomerListsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `CustomerList` at the end of the edge.
  """
  node: CustomerList!
}

"""
Methods to use when ordering `CustomerList`.
"""
enum CustomerListsOrderBy {
  ADDRESS_ASC
  ADDRESS_DESC
  CITY_ASC
  CITY_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  NOTES_ASC
  NOTES_DESC
  PHONE_ASC
  PHONE_DESC
  SID_ASC
  SID_DESC
  ZIP_CODE_ASC
  ZIP_CODE_DESC
}

"""
Represents an update to a `Customer`. Fields that are set will be updated.
"""
input CustomerPatch {
  active: Int
  activebool: Boolean
  addressId: Int
  createDate: Date
  customerId: Int
  email: String
  firstName: String
  lastName: String
  lastUpdate: Datetime
  storeId: Int
}

"""
A connection to a list of `Customer` values.
"""
type CustomersConnection {
  """
  A list of edges which contains the `Customer` and cursor to aid in pagination.
  """
  edges: [CustomersEdge!]!

  """
  A list of `Customer` objects.
  """
  nodes: [Customer!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Customer` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Customer` edge in the connection.
"""
type CustomersEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Customer` at the end of the edge.
  """
  node: Customer!
}

"""
Methods to use when ordering `Customer`.
"""
enum CustomersOrderBy {
  ACTIVEBOOL_ASC
  ACTIVEBOOL_DESC
  ACTIVE_ASC
  ACTIVE_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  CREATE_DATE_ASC
  CREATE_DATE_DESC
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STORE_ID_ASC
  STORE_ID_DESC
}

"""
The day, does not include a time.
"""
scalar Date

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

"""
All input for the `deleteActorByNodeId` mutation.
"""
input DeleteActorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Actor` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteActor` mutation.
"""
input DeleteActorInput {
  actorId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our delete `Actor` mutation.
"""
type DeleteActorPayload {
  """
  The `Actor` that was deleted by this mutation.
  """
  actor: Actor

  """
  An edge for our `Actor`. May be used by Relay 1.
  """
  actorEdge(
    """
    The method to use when ordering `Actor`.
    """
    orderBy: [ActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActorsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedActorNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteAddressByNodeId` mutation.
"""
input DeleteAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteAddress` mutation.
"""
input DeleteAddressInput {
  addressId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our delete `Address` mutation.
"""
type DeleteAddressPayload {
  """
  The `Address` that was deleted by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  Reads a single `City` that is related to this `Address`.
  """
  city: City

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedAddressNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCategoryByNodeId` mutation.
"""
input DeleteCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCategory` mutation.
"""
input DeleteCategoryInput {
  categoryId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our delete `Category` mutation.
"""
type DeleteCategoryPayload {
  """
  The `Category` that was deleted by this mutation.
  """
  category: Category

  """
  An edge for our `Category`. May be used by Relay 1.
  """
  categoryEdge(
    """
    The method to use when ordering `Category`.
    """
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedCategoryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCityByNodeId` mutation.
"""
input DeleteCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCity` mutation.
"""
input DeleteCityInput {
  cityId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
}

"""
The output of our delete `City` mutation.
"""
type DeleteCityPayload {
  """
  The `City` that was deleted by this mutation.
  """
  city: City

  """
  An edge for our `City`. May be used by Relay 1.
  """
  cityEdge(
    """
    The method to use when ordering `City`.
    """
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Country` that is related to this `City`.
  """
  country: Country
  deletedCityNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCountryByNodeId` mutation.
"""
input DeleteCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCountry` mutation.
"""
input DeleteCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: Int!
}

"""
The output of our delete `Country` mutation.
"""
type DeleteCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Country` that was deleted by this mutation.
  """
  country: Country

  """
  An edge for our `Country`. May be used by Relay 1.
  """
  countryEdge(
    """
    The method to use when ordering `Country`.
    """
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge
  deletedCountryNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteCustomerByNodeId` mutation.
"""
input DeleteCustomerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Customer` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteCustomer` mutation.
"""
input DeleteCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  customerId: Int!
}

"""
The output of our delete `Customer` mutation.
"""
type DeleteCustomerPayload {
  """
  Reads a single `Address` that is related to this `Customer`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Customer` that was deleted by this mutation.
  """
  customer: Customer

  """
  An edge for our `Customer`. May be used by Relay 1.
  """
  customerEdge(
    """
    The method to use when ordering `Customer`.
    """
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge
  deletedCustomerNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteFilmActorByNodeId` mutation.
"""
input DeleteFilmActorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FilmActor` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteFilmActor` mutation.
"""
input DeleteFilmActorInput {
  actorId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!
}

"""
The output of our delete `FilmActor` mutation.
"""
type DeleteFilmActorPayload {
  """
  Reads a single `Actor` that is related to this `FilmActor`.
  """
  actor: Actor

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedFilmActorNodeId: ID

  """
  Reads a single `Film` that is related to this `FilmActor`.
  """
  film: Film

  """
  The `FilmActor` that was deleted by this mutation.
  """
  filmActor: FilmActor

  """
  An edge for our `FilmActor`. May be used by Relay 1.
  """
  filmActorEdge(
    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteFilmByNodeId` mutation.
"""
input DeleteFilmByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Film` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteFilmCategoryByNodeId` mutation.
"""
input DeleteFilmCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FilmCategory` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteFilmCategory` mutation.
"""
input DeleteFilmCategoryInput {
  categoryId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!
}

"""
The output of our delete `FilmCategory` mutation.
"""
type DeleteFilmCategoryPayload {
  """
  Reads a single `Category` that is related to this `FilmCategory`.
  """
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedFilmCategoryNodeId: ID

  """
  Reads a single `Film` that is related to this `FilmCategory`.
  """
  film: Film

  """
  The `FilmCategory` that was deleted by this mutation.
  """
  filmCategory: FilmCategory

  """
  An edge for our `FilmCategory`. May be used by Relay 1.
  """
  filmCategoryEdge(
    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteFilm` mutation.
"""
input DeleteFilmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!
}

"""
The output of our delete `Film` mutation.
"""
type DeleteFilmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedFilmNodeId: ID

  """
  The `Film` that was deleted by this mutation.
  """
  film: Film

  """
  An edge for our `Film`. May be used by Relay 1.
  """
  filmEdge(
    """
    The method to use when ordering `Film`.
    """
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmsEdge

  """
  Reads a single `Language` that is related to this `Film`.
  """
  language: Language

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteInventoryByNodeId` mutation.
"""
input DeleteInventoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Inventory` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteInventory` mutation.
"""
input DeleteInventoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  inventoryId: Int!
}

"""
The output of our delete `Inventory` mutation.
"""
type DeleteInventoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedInventoryNodeId: ID

  """
  Reads a single `Film` that is related to this `Inventory`.
  """
  film: Film

  """
  The `Inventory` that was deleted by this mutation.
  """
  inventory: Inventory

  """
  An edge for our `Inventory`. May be used by Relay 1.
  """
  inventoryEdge(
    """
    The method to use when ordering `Inventory`.
    """
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InventoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deleteLanguageByNodeId` mutation.
"""
input DeleteLanguageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Language` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteLanguage` mutation.
"""
input DeleteLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  languageId: Int!
}

"""
The output of our delete `Language` mutation.
"""
type DeleteLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedLanguageNodeId: ID

  """
  The `Language` that was deleted by this mutation.
  """
  language: Language

  """
  An edge for our `Language`. May be used by Relay 1.
  """
  languageEdge(
    """
    The method to use when ordering `Language`.
    """
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `deletePaymentByNodeId` mutation.
"""
input DeletePaymentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Payment` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deletePayment` mutation.
"""
input DeletePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  paymentId: Int!
}

"""
The output of our delete `Payment` mutation.
"""
type DeletePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Payment`.
  """
  customer: Customer
  deletedPaymentNodeId: ID

  """
  The `Payment` that was deleted by this mutation.
  """
  payment: Payment

  """
  An edge for our `Payment`. May be used by Relay 1.
  """
  paymentEdge(
    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Rental` that is related to this `Payment`.
  """
  rental: Rental

  """
  Reads a single `Staff` that is related to this `Payment`.
  """
  staff: Staff
}

"""
All input for the `deleteRentalByNodeId` mutation.
"""
input DeleteRentalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Rental` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteRental` mutation.
"""
input DeleteRentalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  rentalId: Int!
}

"""
The output of our delete `Rental` mutation.
"""
type DeleteRentalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Rental`.
  """
  customer: Customer
  deletedRentalNodeId: ID

  """
  Reads a single `Inventory` that is related to this `Rental`.
  """
  inventory: Inventory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Rental` that was deleted by this mutation.
  """
  rental: Rental

  """
  An edge for our `Rental`. May be used by Relay 1.
  """
  rentalEdge(
    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsEdge

  """
  Reads a single `Staff` that is related to this `Rental`.
  """
  staff: Staff
}

"""
All input for the `deleteStaffByNodeId` mutation.
"""
input DeleteStaffByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Staff` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteStaff` mutation.
"""
input DeleteStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  staffId: Int!
}

"""
The output of our delete `Staff` mutation.
"""
type DeleteStaffPayload {
  """
  Reads a single `Address` that is related to this `Staff`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedStaffNodeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Staff` that was deleted by this mutation.
  """
  staff: Staff

  """
  An edge for our `Staff`. May be used by Relay 1.
  """
  staffEdge(
    """
    The method to use when ordering `Staff`.
    """
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffEdge
}

"""
All input for the `deleteStoreByNodeId` mutation.
"""
input DeleteStoreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Store` to be deleted.
  """
  nodeId: ID!
}

"""
All input for the `deleteStore` mutation.
"""
input DeleteStoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  storeId: Int!
}

"""
The output of our delete `Store` mutation.
"""
type DeleteStorePayload {
  """
  Reads a single `Address` that is related to this `Store`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  deletedStoreNodeId: ID

  """
  Reads a single `Staff` that is related to this `Store`.
  """
  managerStaff: Staff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Store` that was deleted by this mutation.
  """
  store: Store

  """
  An edge for our `Store`. May be used by Relay 1.
  """
  storeEdge(
    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresEdge
}

type Film implements Node {
  description: String

  """
  Reads and enables pagination through a set of `FilmActor`.
  """
  filmActors(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsConnection!

  """
  Reads and enables pagination through a set of `FilmCategory`.
  """
  filmCategories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesConnection!
  filmId: Int!
  fulltext: String!

  """
  Reads and enables pagination through a set of `Inventory`.
  """
  inventories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InventoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Inventory`.
    """
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InventoriesConnection!

  """
  Reads a single `Language` that is related to this `Film`.
  """
  language: Language
  languageId: Int!
  lastUpdate: Datetime!
  length: Int

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  rating: MpaaRating
  releaseYear: Year
  rentalDuration: Int!
  rentalRate: BigFloat!
  replacementCost: BigFloat!
  specialFeatures: [String]
  title: String!
}

type FilmActor implements Node {
  """
  Reads a single `Actor` that is related to this `FilmActor`.
  """
  actor: Actor
  actorId: Int!

  """
  Reads a single `Film` that is related to this `FilmActor`.
  """
  film: Film
  filmId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `FilmActor` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FilmActorCondition {
  """
  Checks for equality with the object’s `actorId` field.
  """
  actorId: Int

  """
  Checks for equality with the object’s `filmId` field.
  """
  filmId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime
}

"""
An input for mutations affecting `FilmActor`
"""
input FilmActorInput {
  actorId: Int!
  filmId: Int!
  lastUpdate: Datetime
}

"""
Represents an update to a `FilmActor`. Fields that are set will be updated.
"""
input FilmActorPatch {
  actorId: Int
  filmId: Int
  lastUpdate: Datetime
}

"""
A connection to a list of `FilmActor` values.
"""
type FilmActorsConnection {
  """
  A list of edges which contains the `FilmActor` and cursor to aid in pagination.
  """
  edges: [FilmActorsEdge!]!

  """
  A list of `FilmActor` objects.
  """
  nodes: [FilmActor!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `FilmActor` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `FilmActor` edge in the connection.
"""
type FilmActorsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `FilmActor` at the end of the edge.
  """
  node: FilmActor!
}

"""
Methods to use when ordering `FilmActor`.
"""
enum FilmActorsOrderBy {
  ACTOR_ID_ASC
  ACTOR_ID_DESC
  FILM_ID_ASC
  FILM_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A connection to a list of `FilmCategory` values.
"""
type FilmCategoriesConnection {
  """
  A list of edges which contains the `FilmCategory` and cursor to aid in pagination.
  """
  edges: [FilmCategoriesEdge!]!

  """
  A list of `FilmCategory` objects.
  """
  nodes: [FilmCategory!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `FilmCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `FilmCategory` edge in the connection.
"""
type FilmCategoriesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `FilmCategory` at the end of the edge.
  """
  node: FilmCategory!
}

"""
Methods to use when ordering `FilmCategory`.
"""
enum FilmCategoriesOrderBy {
  CATEGORY_ID_ASC
  CATEGORY_ID_DESC
  FILM_ID_ASC
  FILM_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

type FilmCategory implements Node {
  """
  Reads a single `Category` that is related to this `FilmCategory`.
  """
  category: Category
  categoryId: Int!

  """
  Reads a single `Film` that is related to this `FilmCategory`.
  """
  film: Film
  filmId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `FilmCategory` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input FilmCategoryCondition {
  """
  Checks for equality with the object’s `categoryId` field.
  """
  categoryId: Int

  """
  Checks for equality with the object’s `filmId` field.
  """
  filmId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime
}

"""
An input for mutations affecting `FilmCategory`
"""
input FilmCategoryInput {
  categoryId: Int!
  filmId: Int!
  lastUpdate: Datetime
}

"""
Represents an update to a `FilmCategory`. Fields that are set will be updated.
"""
input FilmCategoryPatch {
  categoryId: Int
  filmId: Int
  lastUpdate: Datetime
}

"""
A condition to be used against `Film` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input FilmCondition {
  """
  Checks for equality with the object’s `description` field.
  """
  description: String

  """
  Checks for equality with the object’s `filmId` field.
  """
  filmId: Int

  """
  Checks for equality with the object’s `fulltext` field.
  """
  fulltext: String

  """
  Checks for equality with the object’s `languageId` field.
  """
  languageId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `length` field.
  """
  length: Int

  """
  Checks for equality with the object’s `rating` field.
  """
  rating: MpaaRating

  """
  Checks for equality with the object’s `releaseYear` field.
  """
  releaseYear: Year

  """
  Checks for equality with the object’s `rentalDuration` field.
  """
  rentalDuration: Int

  """
  Checks for equality with the object’s `rentalRate` field.
  """
  rentalRate: BigFloat

  """
  Checks for equality with the object’s `replacementCost` field.
  """
  replacementCost: BigFloat

  """
  Checks for equality with the object’s `specialFeatures` field.
  """
  specialFeatures: [String]

  """
  Checks for equality with the object’s `title` field.
  """
  title: String
}

"""
All input for the `filmInStock` mutation.
"""
input FilmInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pFilmId: Int
  pStoreId: Int
}

"""
The output of our `filmInStock` mutation.
"""
type FilmInStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  pFilmCounts: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
An input for mutations affecting `Film`
"""
input FilmInput {
  description: String
  filmId: Int
  fulltext: String!
  languageId: Int!
  lastUpdate: Datetime
  length: Int
  rating: MpaaRating
  releaseYear: Year
  rentalDuration: Int
  rentalRate: BigFloat
  replacementCost: BigFloat
  specialFeatures: [String]
  title: String!
}

type FilmList {
  actors: String
  category: String
  description: String
  fid: Int
  length: Int
  price: BigFloat
  rating: MpaaRating
  title: String
}

"""
A condition to be used against `FilmList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FilmListCondition {
  """
  Checks for equality with the object’s `actors` field.
  """
  actors: String

  """
  Checks for equality with the object’s `category` field.
  """
  category: String

  """
  Checks for equality with the object’s `description` field.
  """
  description: String

  """
  Checks for equality with the object’s `fid` field.
  """
  fid: Int

  """
  Checks for equality with the object’s `length` field.
  """
  length: Int

  """
  Checks for equality with the object’s `price` field.
  """
  price: BigFloat

  """
  Checks for equality with the object’s `rating` field.
  """
  rating: MpaaRating

  """
  Checks for equality with the object’s `title` field.
  """
  title: String
}

"""
A connection to a list of `FilmList` values.
"""
type FilmListsConnection {
  """
  A list of edges which contains the `FilmList` and cursor to aid in pagination.
  """
  edges: [FilmListsEdge!]!

  """
  A list of `FilmList` objects.
  """
  nodes: [FilmList!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `FilmList` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `FilmList` edge in the connection.
"""
type FilmListsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `FilmList` at the end of the edge.
  """
  node: FilmList!
}

"""
Methods to use when ordering `FilmList`.
"""
enum FilmListsOrderBy {
  ACTORS_ASC
  ACTORS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FID_ASC
  FID_DESC
  LENGTH_ASC
  LENGTH_DESC
  NATURAL
  PRICE_ASC
  PRICE_DESC
  RATING_ASC
  RATING_DESC
  TITLE_ASC
  TITLE_DESC
}

"""
All input for the `filmNotInStock` mutation.
"""
input FilmNotInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pFilmId: Int
  pStoreId: Int
}

"""
The output of our `filmNotInStock` mutation.
"""
type FilmNotInStockPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  pFilmCounts: [Int]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
Represents an update to a `Film`. Fields that are set will be updated.
"""
input FilmPatch {
  description: String
  filmId: Int
  fulltext: String
  languageId: Int
  lastUpdate: Datetime
  length: Int
  rating: MpaaRating
  releaseYear: Year
  rentalDuration: Int
  rentalRate: BigFloat
  replacementCost: BigFloat
  specialFeatures: [String]
  title: String
}

"""
A connection to a list of `Film` values.
"""
type FilmsConnection {
  """
  A list of edges which contains the `Film` and cursor to aid in pagination.
  """
  edges: [FilmsEdge!]!

  """
  A list of `Film` objects.
  """
  nodes: [Film!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Film` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Film` edge in the connection.
"""
type FilmsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Film` at the end of the edge.
  """
  node: Film!
}

"""
Methods to use when ordering `Film`.
"""
enum FilmsOrderBy {
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FILM_ID_ASC
  FILM_ID_DESC
  FULLTEXT_ASC
  FULLTEXT_DESC
  LANGUAGE_ID_ASC
  LANGUAGE_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  LENGTH_ASC
  LENGTH_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RATING_ASC
  RATING_DESC
  RELEASE_YEAR_ASC
  RELEASE_YEAR_DESC
  RENTAL_DURATION_ASC
  RENTAL_DURATION_DESC
  RENTAL_RATE_ASC
  RENTAL_RATE_DESC
  REPLACEMENT_COST_ASC
  REPLACEMENT_COST_DESC
  SPECIAL_FEATURES_ASC
  SPECIAL_FEATURES_DESC
  TITLE_ASC
  TITLE_DESC
}

"""
All input for the `getCustomerBalance` mutation.
"""
input GetCustomerBalanceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pCustomerId: Int
  pEffectiveDate: Datetime
}

"""
The output of our `getCustomerBalance` mutation.
"""
type GetCustomerBalancePayload {
  bigFloat: BigFloat

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `Inventory` values.
"""
type InventoriesConnection {
  """
  A list of edges which contains the `Inventory` and cursor to aid in pagination.
  """
  edges: [InventoriesEdge!]!

  """
  A list of `Inventory` objects.
  """
  nodes: [Inventory!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Inventory` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Inventory` edge in the connection.
"""
type InventoriesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Inventory` at the end of the edge.
  """
  node: Inventory!
}

"""
Methods to use when ordering `Inventory`.
"""
enum InventoriesOrderBy {
  FILM_ID_ASC
  FILM_ID_DESC
  INVENTORY_ID_ASC
  INVENTORY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STORE_ID_ASC
  STORE_ID_DESC
}

type Inventory implements Node {
  """
  Reads a single `Film` that is related to this `Inventory`.
  """
  film: Film
  filmId: Int!
  inventoryId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Rental`.
  """
  rentals(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsConnection!
  storeId: Int!
}

"""
A condition to be used against `Inventory` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input InventoryCondition {
  """
  Checks for equality with the object’s `filmId` field.
  """
  filmId: Int

  """
  Checks for equality with the object’s `inventoryId` field.
  """
  inventoryId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `storeId` field.
  """
  storeId: Int
}

"""
All input for the `inventoryHeldByCustomer` mutation.
"""
input InventoryHeldByCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pInventoryId: Int
}

"""
The output of our `inventoryHeldByCustomer` mutation.
"""
type InventoryHeldByCustomerPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  integer: Int

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `inventoryInStock` mutation.
"""
input InventoryInStockInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  pInventoryId: Int
}

"""
The output of our `inventoryInStock` mutation.
"""
type InventoryInStockPayload {
  boolean: Boolean

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
An input for mutations affecting `Inventory`
"""
input InventoryInput {
  filmId: Int!
  inventoryId: Int
  lastUpdate: Datetime
  storeId: Int!
}

"""
Represents an update to a `Inventory`. Fields that are set will be updated.
"""
input InventoryPatch {
  filmId: Int
  inventoryId: Int
  lastUpdate: Datetime
  storeId: Int
}

type Language implements Node {
  """
  Reads and enables pagination through a set of `Film`.
  """
  films(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Film`.
    """
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmsConnection!
  languageId: Int!
  lastUpdate: Datetime!
  name: String!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
A condition to be used against `Language` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input LanguageCondition {
  """
  Checks for equality with the object’s `languageId` field.
  """
  languageId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `name` field.
  """
  name: String
}

"""
An input for mutations affecting `Language`
"""
input LanguageInput {
  languageId: Int
  lastUpdate: Datetime
  name: String!
}

"""
Represents an update to a `Language`. Fields that are set will be updated.
"""
input LanguagePatch {
  languageId: Int
  lastUpdate: Datetime
  name: String
}

"""
A connection to a list of `Language` values.
"""
type LanguagesConnection {
  """
  A list of edges which contains the `Language` and cursor to aid in pagination.
  """
  edges: [LanguagesEdge!]!

  """
  A list of `Language` objects.
  """
  nodes: [Language!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Language` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Language` edge in the connection.
"""
type LanguagesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Language` at the end of the edge.
  """
  node: Language!
}

"""
Methods to use when ordering `Language`.
"""
enum LanguagesOrderBy {
  LANGUAGE_ID_ASC
  LANGUAGE_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

enum MpaaRating {
  G
  NC_17
  PG
  PG_13
  R
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """
  Creates a single `Actor`.
  """
  createActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateActorInput!
  ): CreateActorPayload

  """
  Creates a single `Address`.
  """
  createAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAddressInput!
  ): CreateAddressPayload

  """
  Creates a single `Category`.
  """
  createCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCategoryInput!
  ): CreateCategoryPayload

  """
  Creates a single `City`.
  """
  createCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCityInput!
  ): CreateCityPayload

  """
  Creates a single `Country`.
  """
  createCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCountryInput!
  ): CreateCountryPayload

  """
  Creates a single `Customer`.
  """
  createCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCustomerInput!
  ): CreateCustomerPayload

  """
  Creates a single `Film`.
  """
  createFilm(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFilmInput!
  ): CreateFilmPayload

  """
  Creates a single `FilmActor`.
  """
  createFilmActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFilmActorInput!
  ): CreateFilmActorPayload

  """
  Creates a single `FilmCategory`.
  """
  createFilmCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFilmCategoryInput!
  ): CreateFilmCategoryPayload

  """
  Creates a single `Inventory`.
  """
  createInventory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInventoryInput!
  ): CreateInventoryPayload

  """
  Creates a single `Language`.
  """
  createLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLanguageInput!
  ): CreateLanguagePayload

  """
  Creates a single `Payment`.
  """
  createPayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePaymentInput!
  ): CreatePaymentPayload

  """
  Creates a single `Rental`.
  """
  createRental(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRentalInput!
  ): CreateRentalPayload

  """
  Creates a single `Staff`.
  """
  createStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStaffInput!
  ): CreateStaffPayload

  """
  Creates a single `Store`.
  """
  createStore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStoreInput!
  ): CreateStorePayload

  """
  Deletes a single `Actor` using a unique key.
  """
  deleteActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActorInput!
  ): DeleteActorPayload

  """
  Deletes a single `Actor` using its globally unique id.
  """
  deleteActorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActorByNodeIdInput!
  ): DeleteActorPayload

  """
  Deletes a single `Address` using a unique key.
  """
  deleteAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Address` using its globally unique id.
  """
  deleteAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAddressByNodeIdInput!
  ): DeleteAddressPayload

  """
  Deletes a single `Category` using a unique key.
  """
  deleteCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryInput!
  ): DeleteCategoryPayload

  """
  Deletes a single `Category` using its globally unique id.
  """
  deleteCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCategoryByNodeIdInput!
  ): DeleteCategoryPayload

  """
  Deletes a single `City` using a unique key.
  """
  deleteCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCityInput!
  ): DeleteCityPayload

  """
  Deletes a single `City` using its globally unique id.
  """
  deleteCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCityByNodeIdInput!
  ): DeleteCityPayload

  """
  Deletes a single `Country` using a unique key.
  """
  deleteCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryInput!
  ): DeleteCountryPayload

  """
  Deletes a single `Country` using its globally unique id.
  """
  deleteCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCountryByNodeIdInput!
  ): DeleteCountryPayload

  """
  Deletes a single `Customer` using a unique key.
  """
  deleteCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomerInput!
  ): DeleteCustomerPayload

  """
  Deletes a single `Customer` using its globally unique id.
  """
  deleteCustomerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCustomerByNodeIdInput!
  ): DeleteCustomerPayload

  """
  Deletes a single `Film` using a unique key.
  """
  deleteFilm(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmInput!
  ): DeleteFilmPayload

  """
  Deletes a single `FilmActor` using a unique key.
  """
  deleteFilmActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmActorInput!
  ): DeleteFilmActorPayload

  """
  Deletes a single `FilmActor` using its globally unique id.
  """
  deleteFilmActorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmActorByNodeIdInput!
  ): DeleteFilmActorPayload

  """
  Deletes a single `Film` using its globally unique id.
  """
  deleteFilmByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmByNodeIdInput!
  ): DeleteFilmPayload

  """
  Deletes a single `FilmCategory` using a unique key.
  """
  deleteFilmCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmCategoryInput!
  ): DeleteFilmCategoryPayload

  """
  Deletes a single `FilmCategory` using its globally unique id.
  """
  deleteFilmCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFilmCategoryByNodeIdInput!
  ): DeleteFilmCategoryPayload

  """
  Deletes a single `Inventory` using a unique key.
  """
  deleteInventory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInventoryInput!
  ): DeleteInventoryPayload

  """
  Deletes a single `Inventory` using its globally unique id.
  """
  deleteInventoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInventoryByNodeIdInput!
  ): DeleteInventoryPayload

  """
  Deletes a single `Language` using a unique key.
  """
  deleteLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageInput!
  ): DeleteLanguagePayload

  """
  Deletes a single `Language` using its globally unique id.
  """
  deleteLanguageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLanguageByNodeIdInput!
  ): DeleteLanguagePayload

  """
  Deletes a single `Payment` using a unique key.
  """
  deletePayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentInput!
  ): DeletePaymentPayload

  """
  Deletes a single `Payment` using its globally unique id.
  """
  deletePaymentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentByNodeIdInput!
  ): DeletePaymentPayload

  """
  Deletes a single `Rental` using a unique key.
  """
  deleteRental(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRentalInput!
  ): DeleteRentalPayload

  """
  Deletes a single `Rental` using its globally unique id.
  """
  deleteRentalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRentalByNodeIdInput!
  ): DeleteRentalPayload

  """
  Deletes a single `Staff` using a unique key.
  """
  deleteStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStaffInput!
  ): DeleteStaffPayload

  """
  Deletes a single `Staff` using its globally unique id.
  """
  deleteStaffByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStaffByNodeIdInput!
  ): DeleteStaffPayload

  """
  Deletes a single `Store` using a unique key.
  """
  deleteStore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStoreInput!
  ): DeleteStorePayload

  """
  Deletes a single `Store` using its globally unique id.
  """
  deleteStoreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStoreByNodeIdInput!
  ): DeleteStorePayload
  filmInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: FilmInStockInput!
  ): FilmInStockPayload
  filmNotInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: FilmNotInStockInput!
  ): FilmNotInStockPayload
  getCustomerBalance(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: GetCustomerBalanceInput!
  ): GetCustomerBalancePayload
  inventoryHeldByCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InventoryHeldByCustomerInput!
  ): InventoryHeldByCustomerPayload
  inventoryInStock(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: InventoryInStockInput!
  ): InventoryInStockPayload
  rewardsReport(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: RewardsReportInput!
  ): RewardsReportPayload

  """
  Updates a single `Actor` using a unique key and a patch.
  """
  updateActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActorInput!
  ): UpdateActorPayload

  """
  Updates a single `Actor` using its globally unique id and a patch.
  """
  updateActorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActorByNodeIdInput!
  ): UpdateActorPayload

  """
  Updates a single `Address` using a unique key and a patch.
  """
  updateAddress(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressInput!
  ): UpdateAddressPayload

  """
  Updates a single `Address` using its globally unique id and a patch.
  """
  updateAddressByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAddressByNodeIdInput!
  ): UpdateAddressPayload

  """
  Updates a single `Category` using a unique key and a patch.
  """
  updateCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryInput!
  ): UpdateCategoryPayload

  """
  Updates a single `Category` using its globally unique id and a patch.
  """
  updateCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCategoryByNodeIdInput!
  ): UpdateCategoryPayload

  """
  Updates a single `City` using a unique key and a patch.
  """
  updateCity(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCityInput!
  ): UpdateCityPayload

  """
  Updates a single `City` using its globally unique id and a patch.
  """
  updateCityByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCityByNodeIdInput!
  ): UpdateCityPayload

  """
  Updates a single `Country` using a unique key and a patch.
  """
  updateCountry(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryInput!
  ): UpdateCountryPayload

  """
  Updates a single `Country` using its globally unique id and a patch.
  """
  updateCountryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCountryByNodeIdInput!
  ): UpdateCountryPayload

  """
  Updates a single `Customer` using a unique key and a patch.
  """
  updateCustomer(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomerInput!
  ): UpdateCustomerPayload

  """
  Updates a single `Customer` using its globally unique id and a patch.
  """
  updateCustomerByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCustomerByNodeIdInput!
  ): UpdateCustomerPayload

  """
  Updates a single `Film` using a unique key and a patch.
  """
  updateFilm(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmInput!
  ): UpdateFilmPayload

  """
  Updates a single `FilmActor` using a unique key and a patch.
  """
  updateFilmActor(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmActorInput!
  ): UpdateFilmActorPayload

  """
  Updates a single `FilmActor` using its globally unique id and a patch.
  """
  updateFilmActorByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmActorByNodeIdInput!
  ): UpdateFilmActorPayload

  """
  Updates a single `Film` using its globally unique id and a patch.
  """
  updateFilmByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmByNodeIdInput!
  ): UpdateFilmPayload

  """
  Updates a single `FilmCategory` using a unique key and a patch.
  """
  updateFilmCategory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmCategoryInput!
  ): UpdateFilmCategoryPayload

  """
  Updates a single `FilmCategory` using its globally unique id and a patch.
  """
  updateFilmCategoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFilmCategoryByNodeIdInput!
  ): UpdateFilmCategoryPayload

  """
  Updates a single `Inventory` using a unique key and a patch.
  """
  updateInventory(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInventoryInput!
  ): UpdateInventoryPayload

  """
  Updates a single `Inventory` using its globally unique id and a patch.
  """
  updateInventoryByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInventoryByNodeIdInput!
  ): UpdateInventoryPayload

  """
  Updates a single `Language` using a unique key and a patch.
  """
  updateLanguage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageInput!
  ): UpdateLanguagePayload

  """
  Updates a single `Language` using its globally unique id and a patch.
  """
  updateLanguageByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLanguageByNodeIdInput!
  ): UpdateLanguagePayload

  """
  Updates a single `Payment` using a unique key and a patch.
  """
  updatePayment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentInput!
  ): UpdatePaymentPayload

  """
  Updates a single `Payment` using its globally unique id and a patch.
  """
  updatePaymentByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentByNodeIdInput!
  ): UpdatePaymentPayload

  """
  Updates a single `Rental` using a unique key and a patch.
  """
  updateRental(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRentalInput!
  ): UpdateRentalPayload

  """
  Updates a single `Rental` using its globally unique id and a patch.
  """
  updateRentalByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRentalByNodeIdInput!
  ): UpdateRentalPayload

  """
  Updates a single `Staff` using a unique key and a patch.
  """
  updateStaff(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStaffInput!
  ): UpdateStaffPayload

  """
  Updates a single `Staff` using its globally unique id and a patch.
  """
  updateStaffByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStaffByNodeIdInput!
  ): UpdateStaffPayload

  """
  Updates a single `Store` using a unique key and a patch.
  """
  updateStore(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStoreInput!
  ): UpdateStorePayload

  """
  Updates a single `Store` using its globally unique id and a patch.
  """
  updateStoreByNodeId(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStoreByNodeIdInput!
  ): UpdateStorePayload
}

type NicerButSlowerFilmList {
  actors: String
  category: String
  description: String
  fid: Int
  length: Int
  price: BigFloat
  rating: MpaaRating
  title: String
}

"""
A condition to be used against `NicerButSlowerFilmList` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input NicerButSlowerFilmListCondition {
  """
  Checks for equality with the object’s `actors` field.
  """
  actors: String

  """
  Checks for equality with the object’s `category` field.
  """
  category: String

  """
  Checks for equality with the object’s `description` field.
  """
  description: String

  """
  Checks for equality with the object’s `fid` field.
  """
  fid: Int

  """
  Checks for equality with the object’s `length` field.
  """
  length: Int

  """
  Checks for equality with the object’s `price` field.
  """
  price: BigFloat

  """
  Checks for equality with the object’s `rating` field.
  """
  rating: MpaaRating

  """
  Checks for equality with the object’s `title` field.
  """
  title: String
}

"""
A connection to a list of `NicerButSlowerFilmList` values.
"""
type NicerButSlowerFilmListsConnection {
  """
  A list of edges which contains the `NicerButSlowerFilmList` and cursor to aid in pagination.
  """
  edges: [NicerButSlowerFilmListsEdge!]!

  """
  A list of `NicerButSlowerFilmList` objects.
  """
  nodes: [NicerButSlowerFilmList!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `NicerButSlowerFilmList` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `NicerButSlowerFilmList` edge in the connection.
"""
type NicerButSlowerFilmListsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `NicerButSlowerFilmList` at the end of the edge.
  """
  node: NicerButSlowerFilmList!
}

"""
Methods to use when ordering `NicerButSlowerFilmList`.
"""
enum NicerButSlowerFilmListsOrderBy {
  ACTORS_ASC
  ACTORS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FID_ASC
  FID_DESC
  LENGTH_ASC
  LENGTH_DESC
  NATURAL
  PRICE_ASC
  PRICE_DESC
  RATING_ASC
  RATING_DESC
  TITLE_ASC
  TITLE_DESC
}

"""
An object with a globally unique `ID`.
"""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""
Information about pagination in a connection.
"""
type PageInfo {
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor

  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!

  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!

  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
}

type Payment implements Node {
  amount: BigFloat!

  """
  Reads a single `Customer` that is related to this `Payment`.
  """
  customer: Customer
  customerId: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  paymentDate: Datetime!
  paymentId: Int!

  """
  Reads a single `Rental` that is related to this `Payment`.
  """
  rental: Rental
  rentalId: Int!

  """
  Reads a single `Staff` that is related to this `Payment`.
  """
  staff: Staff
  staffId: Int!
}

"""
A condition to be used against `Payment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PaymentCondition {
  """
  Checks for equality with the object’s `amount` field.
  """
  amount: BigFloat

  """
  Checks for equality with the object’s `customerId` field.
  """
  customerId: Int

  """
  Checks for equality with the object’s `paymentDate` field.
  """
  paymentDate: Datetime

  """
  Checks for equality with the object’s `paymentId` field.
  """
  paymentId: Int

  """
  Checks for equality with the object’s `rentalId` field.
  """
  rentalId: Int

  """
  Checks for equality with the object’s `staffId` field.
  """
  staffId: Int
}

"""
An input for mutations affecting `Payment`
"""
input PaymentInput {
  amount: BigFloat!
  customerId: Int!
  paymentDate: Datetime!
  paymentId: Int
  rentalId: Int!
  staffId: Int!
}

"""
Represents an update to a `Payment`. Fields that are set will be updated.
"""
input PaymentPatch {
  amount: BigFloat
  customerId: Int
  paymentDate: Datetime
  paymentId: Int
  rentalId: Int
  staffId: Int
}

"""
A connection to a list of `Payment` values.
"""
type PaymentsConnection {
  """
  A list of edges which contains the `Payment` and cursor to aid in pagination.
  """
  edges: [PaymentsEdge!]!

  """
  A list of `Payment` objects.
  """
  nodes: [Payment!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Payment` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Payment` edge in the connection.
"""
type PaymentsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Payment` at the end of the edge.
  """
  node: Payment!
}

"""
Methods to use when ordering `Payment`.
"""
enum PaymentsOrderBy {
  AMOUNT_ASC
  AMOUNT_DESC
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  NATURAL
  PAYMENT_DATE_ASC
  PAYMENT_DATE_DESC
  PAYMENT_ID_ASC
  PAYMENT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RENTAL_ID_ASC
  RENTAL_ID_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
}

"""
The root query type which gives access points into the data universe.
"""
type Query implements Node {
  _groupConcat(arg0: String, arg1: String): String
  actor(actorId: Int!): Actor

  """
  Reads a single `Actor` using its globally unique `ID`.
  """
  actorByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Actor`.
    """
    nodeId: ID!
  ): Actor

  """
  Reads and enables pagination through a set of `ActorInfo`.
  """
  actorInfos(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActorInfoCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `ActorInfo`.
    """
    orderBy: [ActorInfosOrderBy!] = [NATURAL]
  ): ActorInfosConnection

  """
  Reads and enables pagination through a set of `Actor`.
  """
  actors(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActorCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Actor`.
    """
    orderBy: [ActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActorsConnection
  address(addressId: Int!): Address

  """
  Reads a single `Address` using its globally unique `ID`.
  """
  addressByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Address`.
    """
    nodeId: ID!
  ): Address

  """
  Reads and enables pagination through a set of `Address`.
  """
  addresses(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AddressCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesConnection

  """
  Reads and enables pagination through a set of `Category`.
  """
  categories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CategoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Category`.
    """
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesConnection
  category(categoryId: Int!): Category

  """
  Reads a single `Category` using its globally unique `ID`.
  """
  categoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Category`.
    """
    nodeId: ID!
  ): Category

  """
  Reads and enables pagination through a set of `City`.
  """
  cities(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CityCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `City`.
    """
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesConnection
  city(cityId: Int!): City

  """
  Reads a single `City` using its globally unique `ID`.
  """
  cityByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `City`.
    """
    nodeId: ID!
  ): City

  """
  Reads and enables pagination through a set of `Country`.
  """
  countries(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CountryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Country`.
    """
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesConnection
  country(countryId: Int!): Country

  """
  Reads a single `Country` using its globally unique `ID`.
  """
  countryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Country`.
    """
    nodeId: ID!
  ): Country
  customer(customerId: Int!): Customer

  """
  Reads a single `Customer` using its globally unique `ID`.
  """
  customerByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Customer`.
    """
    nodeId: ID!
  ): Customer

  """
  Reads and enables pagination through a set of `CustomerList`.
  """
  customerLists(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerListCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `CustomerList`.
    """
    orderBy: [CustomerListsOrderBy!] = [NATURAL]
  ): CustomerListsConnection

  """
  Reads and enables pagination through a set of `Customer`.
  """
  customers(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CustomerCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Customer`.
    """
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersConnection
  film(filmId: Int!): Film
  filmActor(actorId: Int!, filmId: Int!): FilmActor

  """
  Reads a single `FilmActor` using its globally unique `ID`.
  """
  filmActorByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `FilmActor`.
    """
    nodeId: ID!
  ): FilmActor

  """
  Reads and enables pagination through a set of `FilmActor`.
  """
  filmActors(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmActorCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsConnection

  """
  Reads a single `Film` using its globally unique `ID`.
  """
  filmByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Film`.
    """
    nodeId: ID!
  ): Film

  """
  Reads and enables pagination through a set of `FilmCategory`.
  """
  filmCategories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCategoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesConnection
  filmCategory(categoryId: Int!, filmId: Int!): FilmCategory

  """
  Reads a single `FilmCategory` using its globally unique `ID`.
  """
  filmCategoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `FilmCategory`.
    """
    nodeId: ID!
  ): FilmCategory

  """
  Reads and enables pagination through a set of `FilmList`.
  """
  filmLists(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmListCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `FilmList`.
    """
    orderBy: [FilmListsOrderBy!] = [NATURAL]
  ): FilmListsConnection

  """
  Reads and enables pagination through a set of `Film`.
  """
  films(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FilmCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Film`.
    """
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmsConnection

  """
  Reads and enables pagination through a set of `Inventory`.
  """
  inventories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InventoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Inventory`.
    """
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InventoriesConnection
  inventory(inventoryId: Int!): Inventory

  """
  Reads a single `Inventory` using its globally unique `ID`.
  """
  inventoryByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Inventory`.
    """
    nodeId: ID!
  ): Inventory
  language(languageId: Int!): Language

  """
  Reads a single `Language` using its globally unique `ID`.
  """
  languageByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Language`.
    """
    nodeId: ID!
  ): Language

  """
  Reads and enables pagination through a set of `Language`.
  """
  languages(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LanguageCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Language`.
    """
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesConnection
  lastDay(arg0: Datetime!): Date

  """
  Reads and enables pagination through a set of `NicerButSlowerFilmList`.
  """
  nicerButSlowerFilmLists(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NicerButSlowerFilmListCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `NicerButSlowerFilmList`.
    """
    orderBy: [NicerButSlowerFilmListsOrderBy!] = [NATURAL]
  ): NicerButSlowerFilmListsConnection

  """
  Fetches an object given its globally unique `ID`.
  """
  node(
    """
    The globally unique `ID`.
    """
    nodeId: ID!
  ): Node

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!
  payment(paymentId: Int!): Payment

  """
  Reads a single `Payment` using its globally unique `ID`.
  """
  paymentByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Payment`.
    """
    nodeId: ID!
  ): Payment

  """
  Reads and enables pagination through a set of `Payment`.
  """
  payments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsConnection

  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!
  rental(rentalId: Int!): Rental

  """
  Reads a single `Rental` using its globally unique `ID`.
  """
  rentalByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Rental`.
    """
    nodeId: ID!
  ): Rental

  """
  Reads and enables pagination through a set of `Rental`.
  """
  rentals(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsConnection

  """
  Reads and enables pagination through a set of `SalesByFilmCategory`.
  """
  salesByFilmCategories(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SalesByFilmCategoryCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SalesByFilmCategory`.
    """
    orderBy: [SalesByFilmCategoriesOrderBy!] = [NATURAL]
  ): SalesByFilmCategoriesConnection

  """
  Reads and enables pagination through a set of `SalesByStore`.
  """
  salesByStores(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SalesByStoreCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `SalesByStore`.
    """
    orderBy: [SalesByStoresOrderBy!] = [NATURAL]
  ): SalesByStoresConnection
  staff(staffId: Int!): Staff

  """
  Reads a single `Staff` using its globally unique `ID`.
  """
  staffByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Staff`.
    """
    nodeId: ID!
  ): Staff

  """
  Reads and enables pagination through a set of `StaffList`.
  """
  staffLists(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffListCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `StaffList`.
    """
    orderBy: [StaffListsOrderBy!] = [NATURAL]
  ): StaffListsConnection

  """
  Reads and enables pagination through a set of `Staff`.
  """
  staffs(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StaffCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Staff`.
    """
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffConnection
  store(storeId: Int!): Store

  """
  Reads a single `Store` using its globally unique `ID`.
  """
  storeByNodeId(
    """
    The globally unique `ID` to be used in selecting a single `Store`.
    """
    nodeId: ID!
  ): Store

  """
  Reads and enables pagination through a set of `Store`.
  """
  stores(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresConnection
}

type Rental implements Node {
  """
  Reads a single `Customer` that is related to this `Rental`.
  """
  customer: Customer
  customerId: Int!

  """
  Reads a single `Inventory` that is related to this `Rental`.
  """
  inventory: Inventory
  inventoryId: Int!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!

  """
  Reads and enables pagination through a set of `Payment`.
  """
  payments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsConnection!
  rentalDate: Datetime!
  rentalId: Int!
  returnDate: Datetime

  """
  Reads a single `Staff` that is related to this `Rental`.
  """
  staff: Staff
  staffId: Int!
}

"""
A condition to be used against `Rental` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input RentalCondition {
  """
  Checks for equality with the object’s `customerId` field.
  """
  customerId: Int

  """
  Checks for equality with the object’s `inventoryId` field.
  """
  inventoryId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `rentalDate` field.
  """
  rentalDate: Datetime

  """
  Checks for equality with the object’s `rentalId` field.
  """
  rentalId: Int

  """
  Checks for equality with the object’s `returnDate` field.
  """
  returnDate: Datetime

  """
  Checks for equality with the object’s `staffId` field.
  """
  staffId: Int
}

"""
An input for mutations affecting `Rental`
"""
input RentalInput {
  customerId: Int!
  inventoryId: Int!
  lastUpdate: Datetime
  rentalDate: Datetime!
  rentalId: Int
  returnDate: Datetime
  staffId: Int!
}

"""
Represents an update to a `Rental`. Fields that are set will be updated.
"""
input RentalPatch {
  customerId: Int
  inventoryId: Int
  lastUpdate: Datetime
  rentalDate: Datetime
  rentalId: Int
  returnDate: Datetime
  staffId: Int
}

"""
A connection to a list of `Rental` values.
"""
type RentalsConnection {
  """
  A list of edges which contains the `Rental` and cursor to aid in pagination.
  """
  edges: [RentalsEdge!]!

  """
  A list of `Rental` objects.
  """
  nodes: [Rental!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Rental` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Rental` edge in the connection.
"""
type RentalsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Rental` at the end of the edge.
  """
  node: Rental!
}

"""
Methods to use when ordering `Rental`.
"""
enum RentalsOrderBy {
  CUSTOMER_ID_ASC
  CUSTOMER_ID_DESC
  INVENTORY_ID_ASC
  INVENTORY_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  RENTAL_DATE_ASC
  RENTAL_DATE_DESC
  RENTAL_ID_ASC
  RENTAL_ID_DESC
  RETURN_DATE_ASC
  RETURN_DATE_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
}

"""
All input for the `rewardsReport` mutation.
"""
input RewardsReportInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  minDollarAmountPurchased: BigFloat
  minMonthlyPurchases: Int
}

"""
The output of our `rewardsReport` mutation.
"""
type RewardsReportPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String
  customers: [Customer!]

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
A connection to a list of `SalesByFilmCategory` values.
"""
type SalesByFilmCategoriesConnection {
  """
  A list of edges which contains the `SalesByFilmCategory` and cursor to aid in pagination.
  """
  edges: [SalesByFilmCategoriesEdge!]!

  """
  A list of `SalesByFilmCategory` objects.
  """
  nodes: [SalesByFilmCategory!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `SalesByFilmCategory` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `SalesByFilmCategory` edge in the connection.
"""
type SalesByFilmCategoriesEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `SalesByFilmCategory` at the end of the edge.
  """
  node: SalesByFilmCategory!
}

"""
Methods to use when ordering `SalesByFilmCategory`.
"""
enum SalesByFilmCategoriesOrderBy {
  CATEGORY_ASC
  CATEGORY_DESC
  NATURAL
  TOTAL_SALES_ASC
  TOTAL_SALES_DESC
}

type SalesByFilmCategory {
  category: String
  totalSales: BigFloat
}

"""
A condition to be used against `SalesByFilmCategory` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input SalesByFilmCategoryCondition {
  """
  Checks for equality with the object’s `category` field.
  """
  category: String

  """
  Checks for equality with the object’s `totalSales` field.
  """
  totalSales: BigFloat
}

type SalesByStore {
  manager: String
  store: String
  totalSales: BigFloat
}

"""
A condition to be used against `SalesByStore` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SalesByStoreCondition {
  """
  Checks for equality with the object’s `manager` field.
  """
  manager: String

  """
  Checks for equality with the object’s `store` field.
  """
  store: String

  """
  Checks for equality with the object’s `totalSales` field.
  """
  totalSales: BigFloat
}

"""
A connection to a list of `SalesByStore` values.
"""
type SalesByStoresConnection {
  """
  A list of edges which contains the `SalesByStore` and cursor to aid in pagination.
  """
  edges: [SalesByStoresEdge!]!

  """
  A list of `SalesByStore` objects.
  """
  nodes: [SalesByStore!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `SalesByStore` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `SalesByStore` edge in the connection.
"""
type SalesByStoresEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `SalesByStore` at the end of the edge.
  """
  node: SalesByStore!
}

"""
Methods to use when ordering `SalesByStore`.
"""
enum SalesByStoresOrderBy {
  MANAGER_ASC
  MANAGER_DESC
  NATURAL
  STORE_ASC
  STORE_DESC
  TOTAL_SALES_ASC
  TOTAL_SALES_DESC
}

type Staff implements Node {
  active: Boolean!

  """
  Reads a single `Address` that is related to this `Staff`.
  """
  address: Address
  addressId: Int!
  email: String
  firstName: String!
  lastName: String!
  lastUpdate: Datetime!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  password: String

  """
  Reads and enables pagination through a set of `Payment`.
  """
  payments(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsConnection!
  picture: String

  """
  Reads and enables pagination through a set of `Rental`.
  """
  rentals(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RentalCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsConnection!
  staffId: Int!
  storeId: Int!

  """
  Reads and enables pagination through a set of `Store`.
  """
  storesByManagerStaffId(
    """
    Read all values in the set after (below) this cursor.
    """
    after: Cursor

    """
    Read all values in the set before (above) this cursor.
    """
    before: Cursor

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StoreCondition

    """
    Only read the first `n` values of the set.
    """
    first: Int

    """
    Only read the last `n` values of the set.
    """
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresConnection!
  username: String!
}

"""
A condition to be used against `Staff` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StaffCondition {
  """
  Checks for equality with the object’s `active` field.
  """
  active: Boolean

  """
  Checks for equality with the object’s `addressId` field.
  """
  addressId: Int

  """
  Checks for equality with the object’s `email` field.
  """
  email: String

  """
  Checks for equality with the object’s `firstName` field.
  """
  firstName: String

  """
  Checks for equality with the object’s `lastName` field.
  """
  lastName: String

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `password` field.
  """
  password: String

  """
  Checks for equality with the object’s `picture` field.
  """
  picture: String

  """
  Checks for equality with the object’s `staffId` field.
  """
  staffId: Int

  """
  Checks for equality with the object’s `storeId` field.
  """
  storeId: Int

  """
  Checks for equality with the object’s `username` field.
  """
  username: String
}

"""
A connection to a list of `Staff` values.
"""
type StaffConnection {
  """
  A list of edges which contains the `Staff` and cursor to aid in pagination.
  """
  edges: [StaffEdge!]!

  """
  A list of `Staff` objects.
  """
  nodes: [Staff!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Staff` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Staff` edge in the connection.
"""
type StaffEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Staff` at the end of the edge.
  """
  node: Staff!
}

"""
An input for mutations affecting `Staff`
"""
input StaffInput {
  active: Boolean
  addressId: Int!
  email: String
  firstName: String!
  lastName: String!
  lastUpdate: Datetime
  password: String
  picture: String
  staffId: Int
  storeId: Int!
  username: String!
}

type StaffList {
  address: String
  city: String
  country: String
  id: Int
  name: String
  phone: String
  sid: Int
  zipCode: String
}

"""
A condition to be used against `StaffList` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input StaffListCondition {
  """
  Checks for equality with the object’s `address` field.
  """
  address: String

  """
  Checks for equality with the object’s `city` field.
  """
  city: String

  """
  Checks for equality with the object’s `country` field.
  """
  country: String

  """
  Checks for equality with the object’s `id` field.
  """
  id: Int

  """
  Checks for equality with the object’s `name` field.
  """
  name: String

  """
  Checks for equality with the object’s `phone` field.
  """
  phone: String

  """
  Checks for equality with the object’s `sid` field.
  """
  sid: Int

  """
  Checks for equality with the object’s `zipCode` field.
  """
  zipCode: String
}

"""
A connection to a list of `StaffList` values.
"""
type StaffListsConnection {
  """
  A list of edges which contains the `StaffList` and cursor to aid in pagination.
  """
  edges: [StaffListsEdge!]!

  """
  A list of `StaffList` objects.
  """
  nodes: [StaffList!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `StaffList` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `StaffList` edge in the connection.
"""
type StaffListsEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `StaffList` at the end of the edge.
  """
  node: StaffList!
}

"""
Methods to use when ordering `StaffList`.
"""
enum StaffListsOrderBy {
  ADDRESS_ASC
  ADDRESS_DESC
  CITY_ASC
  CITY_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  NATURAL
  PHONE_ASC
  PHONE_DESC
  SID_ASC
  SID_DESC
  ZIP_CODE_ASC
  ZIP_CODE_DESC
}

"""
Methods to use when ordering `Staff`.
"""
enum StaffOrderBy {
  ACTIVE_ASC
  ACTIVE_DESC
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  EMAIL_ASC
  EMAIL_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  NATURAL
  PASSWORD_ASC
  PASSWORD_DESC
  PICTURE_ASC
  PICTURE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STAFF_ID_ASC
  STAFF_ID_DESC
  STORE_ID_ASC
  STORE_ID_DESC
  USERNAME_ASC
  USERNAME_DESC
}

"""
Represents an update to a `Staff`. Fields that are set will be updated.
"""
input StaffPatch {
  active: Boolean
  addressId: Int
  email: String
  firstName: String
  lastName: String
  lastUpdate: Datetime
  password: String
  picture: String
  staffId: Int
  storeId: Int
  username: String
}

type Store implements Node {
  """
  Reads a single `Address` that is related to this `Store`.
  """
  address: Address
  addressId: Int!
  lastUpdate: Datetime!

  """
  Reads a single `Staff` that is related to this `Store`.
  """
  managerStaff: Staff
  managerStaffId: Int!

  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  storeId: Int!
}

"""
A condition to be used against `Store` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StoreCondition {
  """
  Checks for equality with the object’s `addressId` field.
  """
  addressId: Int

  """
  Checks for equality with the object’s `lastUpdate` field.
  """
  lastUpdate: Datetime

  """
  Checks for equality with the object’s `managerStaffId` field.
  """
  managerStaffId: Int

  """
  Checks for equality with the object’s `storeId` field.
  """
  storeId: Int
}

"""
An input for mutations affecting `Store`
"""
input StoreInput {
  addressId: Int!
  lastUpdate: Datetime
  managerStaffId: Int!
  storeId: Int
}

"""
Represents an update to a `Store`. Fields that are set will be updated.
"""
input StorePatch {
  addressId: Int
  lastUpdate: Datetime
  managerStaffId: Int
  storeId: Int
}

"""
A connection to a list of `Store` values.
"""
type StoresConnection {
  """
  A list of edges which contains the `Store` and cursor to aid in pagination.
  """
  edges: [StoresEdge!]!

  """
  A list of `Store` objects.
  """
  nodes: [Store!]!

  """
  Information to aid in pagination.
  """
  pageInfo: PageInfo!

  """
  The count of *all* `Store` you could get from the connection.
  """
  totalCount: Int!
}

"""
A `Store` edge in the connection.
"""
type StoresEdge {
  """
  A cursor for use in pagination.
  """
  cursor: Cursor

  """
  The `Store` at the end of the edge.
  """
  node: Store!
}

"""
Methods to use when ordering `Store`.
"""
enum StoresOrderBy {
  ADDRESS_ID_ASC
  ADDRESS_ID_DESC
  LAST_UPDATE_ASC
  LAST_UPDATE_DESC
  MANAGER_STAFF_ID_ASC
  MANAGER_STAFF_ID_DESC
  NATURAL
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
  STORE_ID_ASC
  STORE_ID_DESC
}

"""
All input for the `updateActorByNodeId` mutation.
"""
input UpdateActorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Actor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Actor` being updated.
  """
  patch: ActorPatch!
}

"""
All input for the `updateActor` mutation.
"""
input UpdateActorInput {
  actorId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Actor` being updated.
  """
  patch: ActorPatch!
}

"""
The output of our update `Actor` mutation.
"""
type UpdateActorPayload {
  """
  The `Actor` that was updated by this mutation.
  """
  actor: Actor

  """
  An edge for our `Actor`. May be used by Relay 1.
  """
  actorEdge(
    """
    The method to use when ordering `Actor`.
    """
    orderBy: [ActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActorsEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateAddressByNodeId` mutation.
"""
input UpdateAddressByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Address` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""
All input for the `updateAddress` mutation.
"""
input UpdateAddressInput {
  addressId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Address` being updated.
  """
  patch: AddressPatch!
}

"""
The output of our update `Address` mutation.
"""
type UpdateAddressPayload {
  """
  The `Address` that was updated by this mutation.
  """
  address: Address

  """
  An edge for our `Address`. May be used by Relay 1.
  """
  addressEdge(
    """
    The method to use when ordering `Address`.
    """
    orderBy: [AddressesOrderBy!] = [PRIMARY_KEY_ASC]
  ): AddressesEdge

  """
  Reads a single `City` that is related to this `Address`.
  """
  city: City

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCategoryByNodeId` mutation.
"""
input UpdateCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Category` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""
All input for the `updateCategory` mutation.
"""
input UpdateCategoryInput {
  categoryId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Category` being updated.
  """
  patch: CategoryPatch!
}

"""
The output of our update `Category` mutation.
"""
type UpdateCategoryPayload {
  """
  The `Category` that was updated by this mutation.
  """
  category: Category

  """
  An edge for our `Category`. May be used by Relay 1.
  """
  categoryEdge(
    """
    The method to use when ordering `Category`.
    """
    orderBy: [CategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CategoriesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCityByNodeId` mutation.
"""
input UpdateCityByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `City` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
}

"""
All input for the `updateCity` mutation.
"""
input UpdateCityInput {
  cityId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `City` being updated.
  """
  patch: CityPatch!
}

"""
The output of our update `City` mutation.
"""
type UpdateCityPayload {
  """
  The `City` that was updated by this mutation.
  """
  city: City

  """
  An edge for our `City`. May be used by Relay 1.
  """
  cityEdge(
    """
    The method to use when ordering `City`.
    """
    orderBy: [CitiesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CitiesEdge

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Country` that is related to this `City`.
  """
  country: Country

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCountryByNodeId` mutation.
"""
input UpdateCountryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Country` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""
All input for the `updateCountry` mutation.
"""
input UpdateCountryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  countryId: Int!

  """
  An object where the defined keys will be set on the `Country` being updated.
  """
  patch: CountryPatch!
}

"""
The output of our update `Country` mutation.
"""
type UpdateCountryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Country` that was updated by this mutation.
  """
  country: Country

  """
  An edge for our `Country`. May be used by Relay 1.
  """
  countryEdge(
    """
    The method to use when ordering `Country`.
    """
    orderBy: [CountriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): CountriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateCustomerByNodeId` mutation.
"""
input UpdateCustomerByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Customer` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Customer` being updated.
  """
  patch: CustomerPatch!
}

"""
All input for the `updateCustomer` mutation.
"""
input UpdateCustomerInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  customerId: Int!

  """
  An object where the defined keys will be set on the `Customer` being updated.
  """
  patch: CustomerPatch!
}

"""
The output of our update `Customer` mutation.
"""
type UpdateCustomerPayload {
  """
  Reads a single `Address` that is related to this `Customer`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Customer` that was updated by this mutation.
  """
  customer: Customer

  """
  An edge for our `Customer`. May be used by Relay 1.
  """
  customerEdge(
    """
    The method to use when ordering `Customer`.
    """
    orderBy: [CustomersOrderBy!] = [PRIMARY_KEY_ASC]
  ): CustomersEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateFilmActorByNodeId` mutation.
"""
input UpdateFilmActorByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FilmActor` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `FilmActor` being updated.
  """
  patch: FilmActorPatch!
}

"""
All input for the `updateFilmActor` mutation.
"""
input UpdateFilmActorInput {
  actorId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!

  """
  An object where the defined keys will be set on the `FilmActor` being updated.
  """
  patch: FilmActorPatch!
}

"""
The output of our update `FilmActor` mutation.
"""
type UpdateFilmActorPayload {
  """
  Reads a single `Actor` that is related to this `FilmActor`.
  """
  actor: Actor

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `FilmActor`.
  """
  film: Film

  """
  The `FilmActor` that was updated by this mutation.
  """
  filmActor: FilmActor

  """
  An edge for our `FilmActor`. May be used by Relay 1.
  """
  filmActorEdge(
    """
    The method to use when ordering `FilmActor`.
    """
    orderBy: [FilmActorsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmActorsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateFilmByNodeId` mutation.
"""
input UpdateFilmByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Film` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Film` being updated.
  """
  patch: FilmPatch!
}

"""
All input for the `updateFilmCategoryByNodeId` mutation.
"""
input UpdateFilmCategoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FilmCategory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `FilmCategory` being updated.
  """
  patch: FilmCategoryPatch!
}

"""
All input for the `updateFilmCategory` mutation.
"""
input UpdateFilmCategoryInput {
  categoryId: Int!

  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!

  """
  An object where the defined keys will be set on the `FilmCategory` being updated.
  """
  patch: FilmCategoryPatch!
}

"""
The output of our update `FilmCategory` mutation.
"""
type UpdateFilmCategoryPayload {
  """
  Reads a single `Category` that is related to this `FilmCategory`.
  """
  category: Category

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `FilmCategory`.
  """
  film: Film

  """
  The `FilmCategory` that was updated by this mutation.
  """
  filmCategory: FilmCategory

  """
  An edge for our `FilmCategory`. May be used by Relay 1.
  """
  filmCategoryEdge(
    """
    The method to use when ordering `FilmCategory`.
    """
    orderBy: [FilmCategoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmCategoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateFilm` mutation.
"""
input UpdateFilmInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  filmId: Int!

  """
  An object where the defined keys will be set on the `Film` being updated.
  """
  patch: FilmPatch!
}

"""
The output of our update `Film` mutation.
"""
type UpdateFilmPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Film` that was updated by this mutation.
  """
  film: Film

  """
  An edge for our `Film`. May be used by Relay 1.
  """
  filmEdge(
    """
    The method to use when ordering `Film`.
    """
    orderBy: [FilmsOrderBy!] = [PRIMARY_KEY_ASC]
  ): FilmsEdge

  """
  Reads a single `Language` that is related to this `Film`.
  """
  language: Language

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateInventoryByNodeId` mutation.
"""
input UpdateInventoryByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Inventory` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Inventory` being updated.
  """
  patch: InventoryPatch!
}

"""
All input for the `updateInventory` mutation.
"""
input UpdateInventoryInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  inventoryId: Int!

  """
  An object where the defined keys will be set on the `Inventory` being updated.
  """
  patch: InventoryPatch!
}

"""
The output of our update `Inventory` mutation.
"""
type UpdateInventoryPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Film` that is related to this `Inventory`.
  """
  film: Film

  """
  The `Inventory` that was updated by this mutation.
  """
  inventory: Inventory

  """
  An edge for our `Inventory`. May be used by Relay 1.
  """
  inventoryEdge(
    """
    The method to use when ordering `Inventory`.
    """
    orderBy: [InventoriesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InventoriesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updateLanguageByNodeId` mutation.
"""
input UpdateLanguageByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Language` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Language` being updated.
  """
  patch: LanguagePatch!
}

"""
All input for the `updateLanguage` mutation.
"""
input UpdateLanguageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  languageId: Int!

  """
  An object where the defined keys will be set on the `Language` being updated.
  """
  patch: LanguagePatch!
}

"""
The output of our update `Language` mutation.
"""
type UpdateLanguagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  The `Language` that was updated by this mutation.
  """
  language: Language

  """
  An edge for our `Language`. May be used by Relay 1.
  """
  languageEdge(
    """
    The method to use when ordering `Language`.
    """
    orderBy: [LanguagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanguagesEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query
}

"""
All input for the `updatePaymentByNodeId` mutation.
"""
input UpdatePaymentByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Payment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Payment` being updated.
  """
  patch: PaymentPatch!
}

"""
All input for the `updatePayment` mutation.
"""
input UpdatePaymentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Payment` being updated.
  """
  patch: PaymentPatch!
  paymentId: Int!
}

"""
The output of our update `Payment` mutation.
"""
type UpdatePaymentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Payment`.
  """
  customer: Customer

  """
  The `Payment` that was updated by this mutation.
  """
  payment: Payment

  """
  An edge for our `Payment`. May be used by Relay 1.
  """
  paymentEdge(
    """
    The method to use when ordering `Payment`.
    """
    orderBy: [PaymentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentsEdge

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Rental` that is related to this `Payment`.
  """
  rental: Rental

  """
  Reads a single `Staff` that is related to this `Payment`.
  """
  staff: Staff
}

"""
All input for the `updateRentalByNodeId` mutation.
"""
input UpdateRentalByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Rental` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Rental` being updated.
  """
  patch: RentalPatch!
}

"""
All input for the `updateRental` mutation.
"""
input UpdateRentalInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Rental` being updated.
  """
  patch: RentalPatch!
  rentalId: Int!
}

"""
The output of our update `Rental` mutation.
"""
type UpdateRentalPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Customer` that is related to this `Rental`.
  """
  customer: Customer

  """
  Reads a single `Inventory` that is related to this `Rental`.
  """
  inventory: Inventory

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Rental` that was updated by this mutation.
  """
  rental: Rental

  """
  An edge for our `Rental`. May be used by Relay 1.
  """
  rentalEdge(
    """
    The method to use when ordering `Rental`.
    """
    orderBy: [RentalsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RentalsEdge

  """
  Reads a single `Staff` that is related to this `Rental`.
  """
  staff: Staff
}

"""
All input for the `updateStaffByNodeId` mutation.
"""
input UpdateStaffByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Staff` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Staff` being updated.
  """
  patch: StaffPatch!
}

"""
All input for the `updateStaff` mutation.
"""
input UpdateStaffInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Staff` being updated.
  """
  patch: StaffPatch!
  staffId: Int!
}

"""
The output of our update `Staff` mutation.
"""
type UpdateStaffPayload {
  """
  Reads a single `Address` that is related to this `Staff`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Staff` that was updated by this mutation.
  """
  staff: Staff

  """
  An edge for our `Staff`. May be used by Relay 1.
  """
  staffEdge(
    """
    The method to use when ordering `Staff`.
    """
    orderBy: [StaffOrderBy!] = [PRIMARY_KEY_ASC]
  ): StaffEdge
}

"""
All input for the `updateStoreByNodeId` mutation.
"""
input UpdateStoreByNodeIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Store` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Store` being updated.
  """
  patch: StorePatch!
}

"""
All input for the `updateStore` mutation.
"""
input UpdateStoreInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Store` being updated.
  """
  patch: StorePatch!
  storeId: Int!
}

"""
The output of our update `Store` mutation.
"""
type UpdateStorePayload {
  """
  Reads a single `Address` that is related to this `Store`.
  """
  address: Address

  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """
  Reads a single `Staff` that is related to this `Store`.
  """
  managerStaff: Staff

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  The `Store` that was updated by this mutation.
  """
  store: Store

  """
  An edge for our `Store`. May be used by Relay 1.
  """
  storeEdge(
    """
    The method to use when ordering `Store`.
    """
    orderBy: [StoresOrderBy!] = [PRIMARY_KEY_ASC]
  ): StoresEdge
}

scalar Year
